## 48.旋转图像

### 遍历

思路：

1、顺时针旋转90，实际上就是将[i,j]放到[j, n-i-1]位置

2、每次顺时针旋转实际上会转一个环，回到原点[i,j]

3、当处于行i时，j取值范围表示当前行的环数量，j的取值范围必须在[i, n-i-1)，不然会和当前i层的环有重合

4、当i行的环处理完毕后，需要在内层同样逻辑处理，由于环的对称性，i只需要处理一半[0,n/2+1)，不然会有重合

5、在同层或者内外层之间，只要有重合结果就会被重复替换，因此要完全避免重合

```java
    public void rotate(int[][] matrix) {
        // 顺时针旋转90，实际上就是将[i,j]放到[j, n-i-1]位置
        int n = matrix.length;
        int count = 0;
      
        // 每次顺时针旋转实际上会转一个环，回到原点[i,j]
        // 因此，当处于行i时，j取值范围表示当前行的环数量，j的取值范围必须在[i, n-i-1)，不然会和当前i层的环有重合
        // 当i行的环处理完毕后，需要在内层同样逻辑处理，由于环的对称性，i只需要处理一半[0,n/2+1)，不然会有重合
        // 在同层或者内外层之间，只要有重合结果就会被重复替换，因此要避免重合
        for(int i = 0; i < n/2+1; i++){
            // 对于列需要处理的范围是从[i, n-i-1)
            for(int j = i; j < n-i-1; j++){
                //System.out.println("i:"+i+"-j:"+j);
                // 定义旋转后的位置
                int rt_i = i, rt_j = j, last_val = matrix[i][j];

                // 当替换的元素等于整个矩阵元素数量时退出
                while(count <= Math.pow(n, 2)){

                    //System.out.print("rt_i:"+rt_i+"-rt_j:"+rt_j+"-last_val:"+last_val);
                    // 计算旋转后位置
                    int temp_i = rt_j;
                    rt_j = n - rt_i - 1;
                    rt_i = temp_i;

                    //System.out.prrt_intln("rt_i:"+rt_i+"-rt_j:"+rt_j);
                    // 交换到目标位置，并保留被覆盖的值，作为下一次待交换的元素
                    int temp = matrix[rt_i][rt_j];
                    matrix[rt_i][rt_j] = last_val;
                    last_val = temp;
                    //System.out.println("---->rt_i:"+rt_i+"-rt_j:"+rt_j+"-last_val:"+last_val);
                    
                    // 每替换一次，计数
                    count++;

                    if(rt_i == i && rt_j == j){
                        break;
                    }
                }
            }
        } 
    }
```

