## 423.从英文中重建数字

### 回溯(超时)

自开始思路是准备逐个英文字母回溯，只要最终出现的总字符数相等就可以，但是超时了，结果不对，但是思路可以留着参考

```java
    public String originalDigits(String s) {
        // 记录字符串中每个字符的次数
        int[] count = new int[26];
        int n = s.length();
        for(int i = 0; i < n; i++){
            count[s.charAt(i)-'a']++;
        }

        //System.out.println("-1"+Arrays.toString(count));

        // 定义一个数字映射数组
        String[] nums = new String[]{"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};  
        StringBuilder sb = new StringBuilder();

        originalDigits(count, nums, sb, 0);

        return sb.toString();
    }

    private boolean originalDigits(int[] count, String[] nums, StringBuilder sb, int index) {
        for(int i = index; i < nums.length; ){
            char[] arr = nums[i].toCharArray();
            boolean exist = true;
            // 判定当前数字是否存在
            for(char ch : arr){
                if(count[ch-'a'] <= 0){
                    exist = false;
                    break;
                }
            }

            if(exist){
                // 做选择
                sb.append(i);
                for(char ch : arr){
                    count[ch-'a']--;
                }

                //  继续开始
                boolean result = originalDigits(count, nums, sb, index);

                // 取消选择
                if(!result){
                    sb.deleteCharAt(sb.length()-1);
                    for(char ch : arr){
                        count[ch-'a']++;
                    }
                    i++;
                }
            }else{
                i++;
            }
        }

        // 最后一定是所有字符全部要用完
        for(int i = 0; i < count.length; i++){
            if(count[i] > 0){
                return false;
            }
        }

        return true;
    }
```



### 数学思路

基于回溯超时，就开始思考是不是要用到公式来计算，又因题中有个条件是`s[i]`仅仅只有15个字符并不是所有26个字符，是可以枚举的，所以考虑公式可能

在观察数字[0-9]对应的英文:"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"后发现一些字符出现的规律如下：

我们分析发现有几个字符只会出现在一个单词[z->zero, w->two, u->four, x->six, g->eight]，所以就有[0,2,4,6,8]这几个数字出现的次数了

但我们还缺少[1,3,5,7,9]这几个数字的次数，我们接着分析
        1、字母s只会出现在six和seven中，因此可以算出7的次数
        2、字母h只会出现在three和eight中，因此可以算出3的次数
        3、字母o只会出现在zero、one、two、four中，因此可以算出1的次数
        4、字母v只会出现在five、seven中，因此可以算出5的次数(前面已经算过7的次数了)
        5、字母i只会出现在five、six、eight、nine中，因此可以算出9的次数

基于上述分析结果，实现代码如下

```java
      public String originalDigits(String s) {
        // 记录字符串中每个字符的次数
        int[] count = new int[26];
        int n = s.length();
        for(int i = 0; i < n; i++){
            count[s.charAt(i)-'a']++;
        }

        //System.out.println(Arrays.toString(count));

        // 定义一个数字出现次数数组
        int[] nums = new int[10];

        // 数字[0-9]对应的英文:"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"
        // 我们分析发现有几个字符只会出现在一个单词[z->zero, w->two, u->four, x->six, g->eight]
        // 因此我们还缺少[1,3,5,7,9]这几个数字的次数，我们接着分析
        // 1、字母s只会出现在six和seven中，因此可以算出7的次数
        // 2、字母h只会出现在three和eight中，因此可以算出3的次数
        // 3、字母o只会出现在zero、one、two、four中，因此可以算出1的次数
        // 4、字母v只会出现在five、seven中，因此可以算出5的次数(前面已经算过7的次数了)
        // 5、字母i只会出现在five、six、eight、nine中，因此可以算出9的次数
        nums[0] = count['z'-'a'];
        nums[2] = count['w'-'a'];
        nums[4] = count['u'-'a'];
        nums[6] = count['x'-'a'];
        nums[8] = count['g'-'a'];
        nums[7] = count['s'-'a'] - nums[6];
        nums[3] = count['h'-'a'] - nums[8];
        nums[1] = count['o'-'a'] - nums[0] - nums[2] - nums[4];
        nums[5] = count['v'-'a'] - nums[7];
        nums[9] = count['i'-'a'] - nums[5] - nums[6] - nums[8];

        //System.out.println(Arrays.toString(nums));

        // 遍历次数数组生成字符串
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < nums.length; i++){
            int cnt = nums[i];
            while(cnt-- > 0){
                sb.append(i);
            }
        }

        return sb.toString();
    }
```

