## 539.最小时间差

### 排序+二维数组

根据题意就是要找出相隔最近的两个时间，因此我们先将`timePoints`升序排序，然后逐个算差，考虑下环形

1、将`timePoints`升序排序，时间差最小的一定是相邻的两个时间

2、将排序后的元素与上一个元素逐个作差，求出分钟数差值

3、需要考虑第一个元素与最后一个元素的差值，例如`00:00`虽然是当天的最早时间，但也是上一天的最晚时间

```java
    public int findMinDifference(List<String> timePoints) {
        Collections.sort(timePoints);
        //System.out.println(timePoints);

        int n = timePoints.size();
        int[][] hm = new int[n][2];
        for(int i = 0; i < n; i++){
            String[] arr = timePoints.get(i).split(":");
            hm[i][0] = Integer.valueOf(arr[0]);
            hm[i][1] = Integer.valueOf(arr[1]);
            //System.out.println(hm[i][0]+":"+hm[i][1]);
        }
        
        // 计算差值（要考虑环，长度是n不是n-1）
        int[] sub = new int[n];
        // 第一个节点用来做环形差
        sub[0] = 60 * ((hm[0][0]+24)-hm[n-1][0]) + (hm[0][1]-hm[n-1][1]);
        for(int i = 1; i < n; i++){
            sub[i] = 60 * (hm[i][0]-hm[i-1][0]) + (hm[i][1]-hm[i-1][1]);
        }
        //System.out.println(Arrays.toString(sub));

        // 找到最小差值
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < n; i++){
            min = Math.min(min, sub[i]);
        }

        return min;
    }
```

分析上述代码，发现二维数据可以简化，用以节省内存空间

```java
    public int findMinDifference(List<String> timePoints) {
        Collections.sort(timePoints);
        int n = timePoints.size();
        //System.out.println(timePoints);

        // 找到最小差值
        int min = Integer.MAX_VALUE, sub = 0;

        // 定义上一个最近的时间
        int last_hour = 0, last_minute = 0;

        for(int i = 0; i < n; i++){
            String[] arr = timePoints.get(i).split(":");
            int hour = Integer.valueOf(arr[0]);
            int minute = Integer.valueOf(arr[1]);
            
            //System.out.println(hm[i][0]+":"+hm[i][1]);
            if(i == 0){
                // sub[0]是最早时间与最晚时间差值
                String[] last = timePoints.get(n-1).split(":");
                last_hour = Integer.valueOf(last[0]);
                last_minute = Integer.valueOf(last[1]);

                sub = 60 * ((hour+24)-last_hour) + (minute-last_minute);
            }else{
                sub = 60 * (hour-last_hour) + (minute-last_minute);  
            }

            // 保存上一个时间的值
            last_hour = hour;   
            last_minute = minute;

            min = Math.min(min, sub);
        }
        //System.out.println(Arrays.toString(sub));

        return min;
    }
```

